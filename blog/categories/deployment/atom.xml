<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: deployment | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/deployment/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2016-09-24T21:15:49+02:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring Cloud Contract 1.0.0.RELEASE available!]]></title>
    <link href="http://toomuchcoding.com/blog/2016/09/24/spring-cloud-contract-1-dot-0-0-dot-release-available/"/>
    <updated>2016-09-24T20:39:25+02:00</updated>
    <id>http://toomuchcoding.com/blog/2016/09/24/spring-cloud-contract-1-dot-0-0-dot-release-available</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve just published an article at the Spring blog about <a href="https://spring.io/blog/2016/09/23/spring-cloud-contract-1-0-0-release-is-available">Spring Cloud Contract 1.0.0.RELEASE is available</a>.</p>

<p>I&rsquo;m really happy that the project is GA. Even though as the Accurest project we had already done a GA release, it really feels that a lot of effort was put in order to release the GA version under the Pivotal&rsquo;s Spring Cloud branding. Let&rsquo;s look at some numbers:</p>

<ul>
<li>first commit almost 2 years ago: <a href="https://github.com/spring-cloud/spring-cloud-contract/commit/dfaddaa98d645b818ba3947c9267ef7ac8ed9ba4">2014-12-06 18:20:29 by Jakub Kubrynski</a></li>
<li><a href="https://github.com/spring-cloud/spring-cloud-contract/commits/master">1.152 commits</a></li>
<li><a href="https://github.com/spring-cloud/spring-cloud-contract/graphs/contributors">20 contributors</a></li>
</ul>


<p>That&rsquo;s quite a lot of work! But there we are, with a library that has already been battle-proven on production by many companies, even before being GA as Spring Cloud Contract.</p>

<!-- more -->


<h2>What&rsquo;s new in comparison to Accurest?</h2>

<p>Like I mentioned, Accurest was already GA. So what are the main difference apart from rebranding and bug fixes?</p>

<ul>
<li>we&rsquo;ve moved from Grapes to Aether to download stubs</li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_what_is_this_value_consumer_producer">we generate fake data when you provide either consumer or producer in the DSL</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_common_repo_with_contracts">Consumer Contract approach is there</a></li>
<li>Spring Cloud Contract is available on <a href="http://start.spring.io">start.spring.io</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts_2">you can have more than one base class for your tests</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_additional_configuration">Spring Cloud Stub Runner Boot can register stubs in Eureka / Consul / Zookeeper using Spring Cloud</a></li>
<li>the whole build was moved from Gradle to the standard Spring Cloud Maven setup</li>
</ul>


<p>These are the Spring Cloud Contract Verifier changes. Apart from that Spring Cloud Contract consists of <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_spring_cloud_contract_wiremock">Spring Cloud Contract WireMock support</a> and <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_generating_stubs_using_restdocs">Spring Cloud Contract RestDocs</a>. Thanks to the first one the integration with <a href="http://wiremock.org">WireMock</a> is much more efficient and thanks to the latter you don&rsquo;t have to use the Groovy DSL - you can define your stubs by yourself by attaching them to an existing RestDocs test.</p>

<p>As far as Spring Cloud Contract Verifier is concerned the biggest two changes are the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_common_repo_with_contracts">Consumer Contract support</a> and that <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts_2">you can have more than one base class for your tests</a>. Let&rsquo;s take a closer look what&rsquo;s there in the docs about them&hellip;</p>

<h3>Consumer Contract support</h3>

<p>Another way of storing contracts other than having them with the producer is keeping them in a common place. It can be related to security issues where the consumers can’t clone the producer’s code. Also if you keep contracts in a single place then you, as a producer, will know how many consumers you have and which consumer will you break with your local changes.</p>

<h4>Repo structure</h4>

<p>Let’s assume that we have a producer with coordinates com.example:server and 3 consumers: client1, client2, client3. Then in the repository with common contracts you would have the following setup (which you can checkout here:</p>

<pre><code>├── com
│   └── example
│       └── server
│           ├── client1
│           │   └── expectation.groovy
│           ├── client2
│           │   └── expectation.groovy
│           ├── client3
│           │   └── expectation.groovy
│           └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml
</code></pre>

<p>As you can see the under the slash-delimited groupid / artifact id folder (<code>com/example/server</code>) you have expectations of the 3 consumers (<code>client1</code>, <code>client2</code> and <code>client3</code>). Expectations are the standard Groovy DSL contract files as described throughout this documentation. This repository has to produce a JAR file that maps one to one to the contents of the repo.</p>

<p>Example of a <code>pom.xml</code> inside the <code>server</code> folder.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;server&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;Server Stubs&lt;/name&gt;
    &lt;description&gt;POM used to install locally stubs for consumer side&lt;/description&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.4.0.BUILD-SNAPSHOT&lt;/version&gt;
        &lt;relativePath /&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-cloud-contract.version&gt;1.0.1.BUILD-SNAPSHOT&lt;/spring-cloud-contract.version&gt;
        &lt;spring-cloud-dependencies.version&gt;Camden.BUILD-SNAPSHOT&lt;/spring-cloud-dependencies.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
                &lt;extensions&gt;true&lt;/extensions&gt;
                &lt;configuration&gt;
                    &lt;!-- By default it would search under src/test/resources/ --&gt;
                    &lt;contractsDirectory&gt;${project.basedir}&lt;/contractsDirectory&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;name&gt;Spring Snapshots&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-releases&lt;/id&gt;
            &lt;name&gt;Spring Releases&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;name&gt;Spring Snapshots&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-releases&lt;/id&gt;
            &lt;name&gt;Spring Releases&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;

&lt;/project&gt;
</code></pre>

<p>As you can see there are no dependencies other than the Spring Cloud Contract Verifier Maven plugin. Those poms are necessary for the consumer side to run <code>mvn clean install -DskipTests</code> to locally install stubs of the producer project.</p>

<p>The <code>pom.xml</code> in the root folder can look like this:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
    &lt;artifactId&gt;contracts&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;Contracts&lt;/name&gt;
    &lt;description&gt;Contains all the Spring Cloud Contracts, well, contracts. JAR used by the producers to generate tests and stubs&lt;/description&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;contracts&lt;/id&gt;
                        &lt;phase&gt;prepare-package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;single&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;attach&gt;true&lt;/attach&gt;
                            &lt;descriptor&gt;${basedir}/src/assembly/contracts.xml&lt;/descriptor&gt;
                            &lt;!-- If you want an explicit classifier remove the following line --&gt;
                            &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>

<p>It’s using the assembly plugin in order to build the JAR with all the contracts. Example of such setup is here:</p>

<pre><code>&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
    &lt;id&gt;project&lt;/id&gt;
    &lt;formats&gt;
        &lt;format&gt;jar&lt;/format&gt;
    &lt;/formats&gt;
    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
    &lt;fileSets&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;${project.basedir}&lt;/directory&gt;
            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
            &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**/${project.build.directory}/**&lt;/exclude&gt;
                &lt;exclude&gt;mvnw&lt;/exclude&gt;
                &lt;exclude&gt;mvnw.cmd&lt;/exclude&gt;
                &lt;exclude&gt;.mvn/**&lt;/exclude&gt;
                &lt;exclude&gt;src/**&lt;/exclude&gt;
            &lt;/excludes&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/assembly&gt;
</code></pre>

<h4>Workflow</h4>

<p>The workflow would look similar to the one presented in the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_step_by_step_guide_to_cdc">Step by step guide to CDC</a>. The only difference is that the producer doesn’t own the contracts anymore. So the consumer and the producer have to work on common contracts in a common repository.</p>

<h4>Consumer</h4>

<p>When the consumer wants to work on the contracts offline, instead of cloning the producer code, the consumer team clones the common repository, goes to the required producer’s folder (e.g. <code>com/example/server</code>) and runs <code>mvn clean install -DskipTests</code> to install locally the stubs converted from the contracts.</p>

<p><strong>REMEMBER! You need to have Maven installed locally</strong></p>

<h4>Producer</h4>

<p>As a producer it’s enough to alter the Spring Cloud Contract Verifier to provide the URL and the dependency of the JAR containing the contracts:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;contractsRepositoryUrl&gt;http://link/to/your/nexus/or/artifactory/or/sth&lt;/contractsRepositoryUrl&gt;
        &lt;contractDependency&gt;
            &lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
            &lt;artifactId&gt;contracts&lt;/artifactId&gt;
        &lt;/contractDependency&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>With this setup the JAR with groupid <code>com.example.standalone</code> and artifactid contracts will be downloaded from <code>http://link/to/your/nexus/or/artifactory/or/sth</code>. It will be then unpacked in a local temporary folder and contracts present under the <code>com/example/server</code> will be picked as the ones used to generate the tests and the stubs. Due to this convention the producer team will know which consumer teams will be broken when some incompatible changes are done.</p>

<p>The rest of the flow looks the same.</p>

<h3>More than one base class</h3>

<p>That was quite a problem when providing one single base class for all the tests. After some time the mock configurations were enormous! That&rsquo;s why we&rsquo;ve added a possibility to map a contract to its test base class.</p>

<h4>Gradle</h4>

<p>If your base classes differ between contracts you can tell the Spring Cloud Contract plugin which class should get extended by the autogenerated tests. You have two options:</p>

<ul>
<li>follow a convention by providing the <code>packageWithBaseClasses</code></li>
<li>provide explicit mapping via <code>baseClassMappings</code></li>
</ul>


<h5>Convention</h5>

<p>The convention is such that if you have a contract under e.g. <code>src/test/resources/contract/foo/bar/baz/</code> and provide the value of the <code>packageWithBaseClasses</code> property to <code>com.example.base</code> then we will assume that there is a <code>BarBazBase</code> class under <code>com.example.base</code> package. In other words we take last two parts of package if they exist and form a class with a <code>Base</code> suffix. Takes precedence over <code>baseClassForTests</code>. Example of usage in the contracts closure:</p>

<pre><code>packageWithBaseClasses = 'com.example.base'
</code></pre>

<h5>Mapping</h5>

<p>You can manually map a regular expression of the contract’s <em>package</em> (package, not folder) to fully qualified name of the base class for the matched contract. Let’s take a look at the following example:</p>

<pre><code>baseClassForTests = "com.example.FooBase"
baseClassMappings {
    baseClassMapping('.*com.*', 'com.example.ComBase')
    baseClassMapping('.*bar.*':'com.example.BarBase')
}
</code></pre>

<p>Let’s assume that you have contracts under</p>

<ul>
<li><code>src/test/resources/contract/com/</code></li>
<li><code>src/test/resources/contract/foo/</code></li>
</ul>


<p>By providing the <code>baseClassForTests</code> we have a fallback in case mapping didn’t succeed (you could also provide the <code>packageWithBaseClasses</code> as fallback). That way the tests generated from <code>src/test/resources/contract/com/</code> contracts will be extending the <code>com.example.ComBase</code> whereas the rest of tests will extend <code>com.example.FooBase</code> cause they don&rsquo;t match the base class mapping for <code>bar</code> folder.</p>

<h4>Maven</h4>

<p>Let&rsquo;s now look how it looks like for Maven.</p>

<h5>Convention</h5>

<p>To accomplish the same result as the one presented for Gradle you&rsquo;d have to set your configuration like this:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;packageWithBaseClasses&gt;com.example.base&lt;/packageWithBaseClasses&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<h5>Mapping</h5>

<p>You can manually map a regular expression of the contract’s package to fully qualified name of the base class for the matched contract. You have to provide a list <code>baseClassMappings</code> of <code>baseClassMapping</code> that takes a <code>contractPackageRegex</code> to <code>baseClassFQN</code> mapping. Let’s take a look at the following example:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;baseClassForTests&gt;com.example.FooBase&lt;/baseClassForTests&gt;
        &lt;baseClassMappings&gt;
            &lt;baseClassMapping&gt;
                &lt;contractPackageRegex&gt;.*com.*&lt;/contractPackageRegex&gt;
                &lt;baseClassFQN&gt;com.example.ComBase&lt;/baseClassFQN&gt;
            &lt;/baseClassMapping&gt;
            &lt;baseClassMapping&gt;
                &lt;contractPackageRegex&gt;.*bar.*&lt;/contractPackageRegex&gt;
                &lt;baseClassFQN&gt;com.example.BarBase&lt;/baseClassFQN&gt;
            &lt;/baseClassMapping&gt;
        &lt;/baseClassMappings&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<h2>Summary</h2>

<p>In this blog post we&rsquo;ve checked what are the new and shiny features in the GA of Spring Cloud Contract. We&rsquo;ve also checked some history around Accurest to Spring Cloud Contract migration.</p>

<h2>Links</h2>

<p>Here you can find interesting links related to Spring Cloud Contract Verifier:</p>

<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-contract/">Spring Cloud Contract Github Repository</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/">Spring Cloud Contract Main project page</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html">Spring Cloud Contract Documentation</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_spring_cloud_contract_stub_runner">Spring Cloud Contract Stub Runner Documentation</a></li>
<li><a href="https://gitter.im/spring-cloud/spring-cloud-contract">Spring Cloud Contract Gitter</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/">Spring Cloud Contract Maven Plugin Documentation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Cloud Contract 1.0.0.M1 Released]]></title>
    <link href="http://toomuchcoding.com/blog/2016/07/25/spring-cloud-contract-1-dot-0-0-dot-m1-released/"/>
    <updated>2016-07-25T17:07:39+02:00</updated>
    <id>http://toomuchcoding.com/blog/2016/07/25/spring-cloud-contract-1-dot-0-0-dot-m1-released</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve just published an article at the Spring blog about <a href="https://spring.io/blog/2016/07/25/spring-cloud-contract-1-0-0-m1-released">Spring Cloud Contract 1.0.0.M1 Release</a>. Check out the new project formerly known as Accurest!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accurest becomes part of the Spring Cloud Contract]]></title>
    <link href="http://toomuchcoding.com/blog/2016/06/24/accurest-becomes-part-of-the-spring-cloud-contract/"/>
    <updated>2016-06-24T18:43:07+02:00</updated>
    <id>http://toomuchcoding.com/blog/2016/06/24/accurest-becomes-part-of-the-spring-cloud-contract</id>
    <content type="html"><![CDATA[<p>I&rsquo;m extremely happy to announce that we have successfully rebranded the <a href="https://codearte.github.io/accurest">Accurest project</a>. It&rsquo;s officially become part of the <a href="https://github.com/spring-cloud/spring-cloud-contract">Spring Cloud Contract</a> initiative. Ladies and Gentlemen please welcome the new projects:</p>

<ul>
<li><a href="https://codearte.github.io/accurest/">Spring Cloud Contract Verifier</a></li>
<li><a href="https://codearte.github.io/accurest/#spring-cloud-contract-stub-runner">Spring Cloud Contract Stub Runner</a></li>
</ul>


<!-- more -->


<h2>A little bit of history</h2>

<p>Accurest was created because of lack of an easy-to-use tool for doing <a href="http://martinfowler.com/articles/consumerDrivenContracts.html">Consumer Driven Contracts</a>. From our production experience the biggest problem was lack of verification that the defined contract actually does what it says it does. We wanted to ensure that from the contract automatically tests are generated so that we can have a proof that the stubs are reliable. Since there was no such tool the first commit of Accurest took place on 12/2014. The very idea and its implementation was initially set by <a href="http://www.kubrynski.com/">Jakub Kubrynski</a> and me. The last available version of Accurest was 1.1.0 released on 06/2016 (the docs for the old version are <a href="https://codearte.github.io/accurest/deprecated/">available here</a>). During these 19 months a lot of feedback has been gathered. The tool has received a lot of very good reception and that made us want to work even harder. Many times we have decided to decrease the time required for sleeping so as to fix a bug or develop a new feature in Accurest.</p>

<h2>Notable features</h2>

<p>Speaking of features, especially quite a few of them definitely makes Accurest stand out on the &ldquo;market&rdquo; of Consumer Driven Contract (CDC) tooling. Out of many the most interesting are:</p>

<ul>
<li>Possibility to do CDC with messaging</li>
<li>Clear and easy to use, statically typed DSL</li>
<li>Possibility to copy paste your current JSON file to the contract and only edit its elements</li>
<li>Automatic generation of tests from the defined Contract</li>
<li>Stub Runner functionality - the stubs are automatically downloaded at runtime from Nexus / Artifactory</li>
<li>Spring Cloud integration - no discovery service is needed for integration tests</li>
</ul>


<p>For more information check out my posts about <a href="http://toomuchcoding.com/blog/2016/04/06/accurest-stubrunner-released/">Stub Runner</a>, <a href="http://toomuchcoding.com/blog/2016/04/30/accurest-and-stub-runner-1-dot-1-0-dot-m3/">Accurest Messaging</a> or <a href="https://codearte.github.io/accurest/">just read the docs</a>.</p>

<h2>Spring Cloud Contract</h2>

<p>In Pivotal we came to the conclusion that Accurest could become an interesting addition to our Spring Cloud tooling. Due to the increased interest of the community in the Consumer Driven Contracts approach we&rsquo;ve decided to start the <a href="https://github.com/spring-cloud/spring-cloud-contract">Spring Cloud Contract</a> initiative.</p>

<p>Accurest became <em>Spring Cloud Contract Verifier</em> (note: the name might change in the future) but for the time being will remain in the <a href="https://github.com/Codearte">Codearte repository</a>. It&rsquo;s becoming the part of Spring Cloud tooling as a mature tool with a growing community around it. Some arguments for that are that it has:</p>

<ul>
<li><a href="https://codearte.github.io/accurest/">a nice AsciiDoc documentation that was completely rewritten following users' feedback</a></li>
<li><a href="https://gitter.im/Codearte/accurest">active Gitter channel where we try to immediately answer any support questions</a></li>
<li><a href="https://github.com/Codearte/accurest/stargazers">Over 80 stars on Github and counting ;)</a></li>
</ul>


<p>Since we believe very much in the Consumer Driven Contract approach we also want to do the library in a Client Driven way. That means that we (server side) are very open to your feedback (consumer side) and want you be the main driver of changes in the library.</p>

<h2>Credits</h2>

<p>The Accurest project would never come to life without the hard work of the <a href="http://codearte.io">Codearte</a> developers (the order is random):</p>

<ul>
<li><a href="https://twitter.com/olga_maciaszek">Olga Maciaszek-Sharma</a></li>
<li><a href="http://www.kubrynski.com">Jakub Kubrynski</a></li>
<li><a href="https://solidsoft.wordpress.com/">Marcin Zajaczkowski</a></li>
<li><a href="https://github.com/mariuszs">Mariusz Smykula</a></li>
</ul>


<p>and obviously everybody who has <a href="https://github.com/Codearte/accurest/graphs/contributors">ever commited something to the project</a>.</p>

<h2>Links</h2>

<p>If you want to read more about <em>Spring Cloud Contract Verifier</em> just check out the following links.</p>

<ul>
<li><a href="https://github.com/Codearte/accurest">Spring Cloud Contract Verifier Github Repository</a></li>
<li><a href="http://codearte.github.io/accurest">Spring Cloud Contract Verifier Documentation</a></li>
<li><a href="http://codearte.github.io/accurest/deprecated">Accurest Legacy Documentation</a></li>
<li><a href="https://codearte.github.io/accurest/#spring-cloud-contract-stub-runner">Spring Cloud Contract Stub Runner Documentation</a></li>
<li><a href="http://codearte.github.io/accurest/#stub-runner-for-messaging">Spring Cloud Contract Stub Runner Messaging Documentation</a></li>
<li><a href="https://gitter.im/Codearte/accurest">Spring Cloud Contract Verifier Gitter</a></li>
<li><a href="https://github.com/Codearte/accurest-maven-plugin">Spring Cloud Contract Verifier Maven Plugin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zero Downtime Deployment with a Database]]></title>
    <link href="http://toomuchcoding.com/blog/2016/05/31/zero-downtime-deployment-with-a-database/"/>
    <updated>2016-05-31T11:58:52+02:00</updated>
    <id>http://toomuchcoding.com/blog/2016/05/31/zero-downtime-deployment-with-a-database</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve just published an article at the Spring blog about <a href="https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database">Zero Downtime Deployment with a Database</a>. So if you&rsquo;re planning on doing
zero downtime or blue/green deployment you&rsquo;d better check out that article :) The code is available here on
<a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microservice Deployment]]></title>
    <link href="http://toomuchcoding.com/blog/2015/09/27/microservice-deployment/"/>
    <updated>2015-09-27T00:13:00+02:00</updated>
    <id>http://toomuchcoding.com/blog/2015/09/27/microservice-deployment</id>
    <content type="html"><![CDATA[<div class='post'>
It's been a while since my last post. In the meantime of course nothing has changed in terms of the microservice hype. I've been &nbsp;attending many microservice's talks and what I'm always missing are concrete details on many different subjects. One of which is deployment. In this post I'll try to depict how in a big, multinational company one would want to do microservice deployment. I'll walk you through the most basic deployment pipeline that could be created in such an enterprise.<br /><br /><a name='more'></a>
<!--more-->
<br /><h4>The goal</h4>Our goal was to:<br /><br /><b>Enforce standards</b><br /><b><br /></b>Have a unique way of deploying alll microservices - we need to enforce standards<br /><br /><b>Tackle the microservice dependencies complexity issue</b><br /><br />Make the deployment process maintainable from the infrastructure and operations perspective<br /><br /><b>Make the pipeline fast and certain</b><br /><br />Have the greatest possible certainty that our features are working fine.<br />We wanted to make the deployment pipeline as fast as possible.<br />It was crucial to add the possibility to automatically rollback if something goes wrong.<br /><br /><h4>Enforce standards</h4>It is crucial that if you're starting with microservices you start introducing standards. Standards of running applications, configuring them (externalized properties) but also you should enforce standards in how you deploy your applications. At some point in time we have seen that different applications do common tasks in different ways.<br /><br />Why should we bother - we have business value to deliver and not waste time on enforcing standards - your manager might say. Actually he is really wrong because you're wasting plenty of time (thus money) on supporting such nonstandard applications. Imagine how much it needs for the new developers to understand how exactly the rules are set in this particular process.<br /><br />The same relates to deployment and deployment pipelines. That's why we decided to enforce one, single way of deploying microservices.<br /><br /><h4><span style="font-weight: normal;">Tackle the microservice dependencies complexity issue</span></h4><br />If you have two monolithic applications talking to each other and not too many developers working on the codebases you can queue deployment of both apps and always perform end to end tests.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-G80VsWKpIy0/VgbyR9nENVI/AAAAAAABII4/rYV8ZIMJi6A/s1600/monolith.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="124" src="https://2.bp.blogspot.com/-G80VsWKpIy0/VgbyR9nENVI/AAAAAAABII4/rYV8ZIMJi6A/s320/monolith.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Two monolithic applications deployed for end to end testing</td></tr></tbody></table><div class="separator" style="clear: both; text-align: left;">In case of microservices the scale starts to be a problem:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-kggPwWHR-iQ/VgbyhX1x5aI/AAAAAAABIJA/tf2lLkCruxA/s1600/many_microservices.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="207" src="https://2.bp.blogspot.com/-kggPwWHR-iQ/VgbyhX1x5aI/AAAAAAABIJA/tf2lLkCruxA/s320/many_microservices.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Many microservices deployed in different versions</td></tr></tbody></table><div class="separator" style="clear: both; text-align: left;">The questions arise:</div><div class="separator" style="clear: both; text-align: left;"></div><ul><li>Should I queue deployments of microservices on one testing environment or should I have an environment per microservice?&nbsp;</li><ul><li>If I queue deployments people will have to wait for hours to have their tests ran - that can be a problem</li></ul><li>To remove that issue I can have an environment per microservice&nbsp;</li><ul><li>Who will pay the bills (imagine 100 microservices - each having each own environment).&nbsp;</li><li>Who will support each of those environments?</li><li>Should we spawn a new environment each time we execute a new pipeline and then wrap it up or should we have them up and running for the whole day?</li></ul><li>In which versions should I deploy the dependent microservices - development or production versions?</li><ul><li>If I have development versions then I can test my application against a feature that is not yet on production. That can lead to exceptions on production</li><li>If I test against production versions then I'll never be able to test against a feature under development anytime before deployment to production.</li></ul></ul><h4>Make the pipeline fast and certain</h4><div><br /></div><div>Since we really believe in the agile methodology and continuous deployment we would like our features to be delivered to production as fast as possible. When working with the monolithic applications we've faced the following issues:</div><div><ul><li>For monolithic applications we had plenty of unit, integration and end to end tests</li><li>The different types of tests covered the same functionality up to three times</li><li>The tests took a lot of time to run</li></ul><div>Having all of this in mind we wanted not to have such issues with our new deployment pipeline.</div><div><br /></div></div><br /><div class="separator" style="clear: both; text-align: left;"></div><h4>Simplify the infrastructure complexity</h4><div><br /></div><div>Due to technical issues, difficulties to maintain the spawned environments we've decided to simplify the pipeline as much as possible. That's why since we are enthusiasts of TDD and we know what Consumer Driven Contract is we've decided not to do End to End tests. We're deploying our application to a virtual machine where the executed tests don't interfere with other pipelines executed in the very same time.</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-3BIKN1VzDKA/Vgb7oxk8jXI/AAAAAAABIJQ/q_A0LifBgEI/s1600/stubbed_dependencies.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="203" src="https://3.bp.blogspot.com/-3BIKN1VzDKA/Vgb7oxk8jXI/AAAAAAABIJQ/q_A0LifBgEI/s320/stubbed_dependencies.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Execute tests on a deployed microservice on stubbed dependencies</td></tr></tbody></table><div>That way you can look at your application tests (we called them smoke tests) in the following way:</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-7jseO68-q6A/Vgb8h7Ia1CI/AAAAAAABIJc/C8W0S4qZAic/s1600/no_e2e_tests.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="303" src="https://3.bp.blogspot.com/-7jseO68-q6A/Vgb8h7Ia1CI/AAAAAAABIJc/C8W0S4qZAic/s320/no_e2e_tests.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">We're testing microservices in isolation</td></tr></tbody></table><div>Why smoke tests? Because we deliberately want to enforce the testing pyramid in the following way:</div><div><ul><li>A lot of unit tests executed during build time</li><li>Some integration tests running on stubs of dependent services executed during build time</li><li>Not many acceptance tests&nbsp;running on stubs of dependent services executed during build time (these can be treated as special case of integration tests)</li><li>A handful of smoke tests executed on a deployed application to see if the app is really packaged properly</li></ul></div><div><br /></div><div>Such an approach to testing and deployment gives the following benefits:</div><div><ul><li>No need to deploy dependent services</li><li>The stubs used for the tests ran on a deployed microservice are the same as those used during integration tests</li><li>Those stubs have been tested against the application that produces them (check <a href="https://github.com/Codearte/accurest">Accurest</a> for more information)</li><li>We don't have many slow tests running on a deployed application - thus the pipeline gets executed much faster</li><li>We don't have to queue deployments - we're testing in isolation thus pipelines don't interfere with each other</li><li>We don't have to spawn virtual machines each time for deployment purposes</li></ul></div><div><br /></div><div>It brings however the following challenges:</div><div><ul><li>No end to end tests before production - you don't have the full certainty that a feature is working</li><li>Due to this certainty that the functionality is working decreases</li><li>First time the applications will talk in a real way will be on production</li></ul></div><h4>Overcoming fear of uncertainty</h4><div><br /></div><div>The argument that we don't know if a functionality is working properly made us invest more time and effort in tools that will give us more information on how our applications work on production. That's why we've added plenty of monitoring both technical and business via Graphite. Also we've introduced Seyren as the alerting mechanism to ping us immediately when something is really wrong on production.</div><div><br /></div><div>Whatever time you spend on improving your tests, testing environments or UATs with endless hours of clicking - it will never signify that on production your application will run in the same manner.</div><div><br /></div><div>Our decisions were related to trade offs. We decided to give away the complexity in the artificial test environments. That complexity was pushed to the monitoring of production instances. With microservices there is never an easy decision - there's always some price needed to pay.</div><div><br /></div><h4>The technical overview of the solution</h4><div><br /></div><div>We've divided the simplest scenario of the microservice deployment pipeline into the following steps.</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-JmkGUgmrI8Q/Vgb-y9Eg9RI/AAAAAAABIJo/QMa0rkaSfUk/s1600/Microservice%2BPipeline.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="305" src="https://4.bp.blogspot.com/-JmkGUgmrI8Q/Vgb-y9Eg9RI/AAAAAAABIJo/QMa0rkaSfUk/s640/Microservice%2BPipeline.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Microservice deployment pipeline (without A/B testing)</td></tr></tbody></table><div><b><u>Build the app (after commit)</u></b></div><div><br /></div><div>Most preferably we would like after each merge of a PR trigger the deployment pipeline (thus do Continuous Deployment).&nbsp;</div><div><br /></div><div>The result of this step would be to have the application tested in the following ways:</div><div><ul><li>unit and integration tests are ran</li><li>validity of declared stubs specifications is tested against the application itself</li></ul></div><div>Finally what is published to Nexus is the fat-jar of the application together with its stubs.&nbsp;</div><div><br /></div><div><b><u>Deploy to staging</u></b></div><div><br /></div><div>We deploy our freshly built application to the staging environment. <a href="https://github.com/4finance/micro-infra-spring/wiki/Stub-runner">Micro Infra Spring Stub-runner</a> is responsible for downloading the current <b>development</b>&nbsp;versions of stubs of declared dependencies of the microservice.&nbsp;</div><div><br /></div><div>In the first version of the pipeline we've decided to go towards development versions since we would like each of the applications to go live after each commit. That means that there is a high probability that the development version of a stub is in fact the production one. Of course that not necessarily needs to be true - but this is our trade off.</div><div><br /></div><div>In the future versions of the pipeline we would like to test the app against both development and production versions of stubs.&nbsp;</div><div><br /></div><div><b>What is very important to see is that in this step we are upgrading the microservice's DB schema.</b></div><div><b><br /></b></div><div><b><u>Test application rollback scenario</u></b></div><div><br /></div><div>We don't want to rollback the database. If you have MongoDB like databases there is no schema in fact. If you have Liquibase - you can provide the rollback scripts for relational DBs. They however introduce complexity on the DB level.</div><div><br /></div><div>We've decided to go with a trade off that the complexity goes out from the DB level to the code. We're not rolling back the DB but we're rolling back the application. That means that the developers need to write their code to support backwards compatibility.&nbsp;</div><div><br /></div><div><b>That means that the NEW version of the application MUST support the OLD schema of the database. Also developers MUST NOT do backwards incompatible changes in subsequent liquibase scripts.</b></div><div><b><br /></b></div><div>We're running old smoke tests on the rolled back version of the application that is connected to the new version of the schema. That way we can ensure that most probably we will be able to rollback on production without greater issues.</div><div><br /></div><div><b><u>Deploy to production</u></b></div><div><br /></div><div>If the smoke tests have passed and we've checked the rollback procedures we can go live. Here the monitoring part comes in. We need to ensure that we've put all the KPI checking alerts in place. As a part of deployment procedure a review of monitoring and alerts needs to take place.</div><div><br /></div><div>As you can see in the picture the first scenario of live deployment doesn't include 0 downtime approach. That was yet another trade off that we've decided to take. We don't want to tackle the issue of automatic data migration right now. Also for the developers writing code that supports both old and new schema is actually mind blowing. That's why we want to do things a step at a time - for now we kill all the application instances on production, boot one up and &nbsp;change the schema and then boot the rest up too.</div><div><br /></div><br /><div class="separator" style="clear: both; text-align: left;"><b><u>Rollback procedure</u></b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">If our KPI monitoring starts to go all red on production then we need to rollback as fast as possible. Since we've tested the rollback procedure it shouldn't be an issue on production to kill all the instances, download the previous version of the app and run it against the new schema.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><h4 style="clear: both; text-align: left;">Summary</h4><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">As everything related to distributed systems - you can see that microservice deployment is not easy. Actually it's full of trade offs and complexity. Starting from the infrastructure going through testing and finishing with database schema changes.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">The presented solution seems to be an acceptable compromise between time, effort, certainty and feedback.</div></div>

]]></content>
  </entry>
  
</feed>
