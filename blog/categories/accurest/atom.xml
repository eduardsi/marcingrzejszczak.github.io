<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: accurest | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/accurest/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2016-04-25T21:54:55+02:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Accurest docs updated]]></title>
    <link href="http://toomuchcoding.com/blog/2016/04/25/accurest-docs-updated/"/>
    <updated>2016-04-25T21:49:59+02:00</updated>
    <id>http://toomuchcoding.com/blog/2016/04/25/accurest-docs-updated</id>
    <content type="html"><![CDATA[<p>After a lot of sleepless nights I&rsquo;ve finally migrated the <a href="http://codearte.github.io/accurest/">Accurest Docs</a> from Github&rsquo;s Wiki to Asciidoctor.
With that change the vast majority of our snippets is taken from the tests. Also thanks to that change it will be much easier to keep the docs up to date
since the documentation lives together with the code.</p>

<p>Quite frankly recently when I didn&rsquo;t code <a href="https://github.com/spring-cloud/spring-cloud-sleuth">Spring Cloud Sleuth</a> I did a lot around <a href="http://codearte.github.io/accurest/">Accurest</a> and messaging so stay tuned! For sure there will be a new post about Consumer Driven Contracts and Messaging.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AccuREST Stub Runner Released]]></title>
    <link href="http://toomuchcoding.com/blog/2016/04/06/accurest-stubrunner-released/"/>
    <updated>2016-04-06T11:05:58+02:00</updated>
    <id>http://toomuchcoding.com/blog/2016/04/06/accurest-stubrunner-released</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a good release time recently! I&rsquo;m blogging here at <a href="http://toomuchcoding.com">Too Much Coding blog</a> more about releases then about any concrete topics ;)</p>

<p>After releasing <a href="/blog/2016/03/25/spring-cloud-sleuth-rc1-deployed/">Spring Cloud Sleuth as a part of Brixton RC1</a> we have just released a version 1.0.4 of <a href="https://github.com/Codearte/accurest">AccuREST</a>. We&rsquo;ve fixed a couple
of bugs but we&rsquo;ve introduced a couple of big features including:</p>

<ul>
<li><a href="https://github.com/Codearte/accurest-maven-plugin">Maven plugin support</a></li>
<li><em>Stub Runner</em> functionality</li>
</ul>


<p>This post will describe the latter feature in more depth.</p>

<!-- more -->


<h2>Introduction</h2>

<p>I&rsquo;ve given quite a few talks about the library called <a href="https://github.com/4finance/micro-infra-spring">Micro-Infra-Spring</a> where I presented how you can profit from the <em>Stub Runner</em> functionality. Since my leaving the company owning that repository, the project is almost not maintained at all. For quite a long time any development was done mostly by me and actually I was the author of most of the <em>Stub Runner&rsquo;s</em> code. Due to the aforementioned and the fact that <em>Stub Runner</em> is tightly coupled with AccuREST&rsquo;s stub generation feature I&rsquo;ve decided to migrate it to the AccuREST&rsquo;s repository.</p>

<h2>AccuREST recap</h2>

<p><em>Stub Runner</em> is tightly coupled with the concepts coming from AccuREST. For more information about AccuREST you can check my <a href="/blog/categories/accurest/">blog entries</a> or check <a href="https://github.com/Codearte/accurest">AccuREST project on Github</a>. If you don&rsquo;t have a clue what that is I&rsquo;ll try to do a very fast recap.</p>

<p>AccuREST is a <a href="http://martinfowler.com/articles/consumerDrivenContracts.html">Consumer Driven Contracts</a> verifier in which you define the contract of your API via a Groovy DSL. From that DSL, on the server side, tests are created to check if your contract is telling the truth. From the <em>Stub Runner&rsquo;s</em> perspective more interesting is the client side. For the client side AccuREST generates WireMock stubs from the provided DSL so that the clients of that API can be provided with reliable stubs.</p>

<h2>What is Stub Runner?</h2>

<p>Now that we remember what AccuREST does we can take a look in more depth at <em>Stub Runner</em>. Let&rsquo;s assume that we have a following flow of services (btw. <a href="http://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html">this is a screenshot from Zipkin integrated with Spring Cloud Sleuth</a> )</p>

<p><img src="/images/accurest/stubrunner/dependencies_accurest.png" alt="Dependencies" /></p>

<p>Let&rsquo;s imagine ourselves as developers of the <em>service2</em> - the one that calls <em>service3</em> and <em>service4</em>. Since we&rsquo;re doing the CDC (<a href="http://martinfowler.com/articles/consumerDrivenContracts.html">Consumer Driven Contracts</a>) approach let&rsquo;s assume that the stubs of <em>service3</em> and <em>service4</em> got already deployed to some Maven repository.</p>

<p>If I&rsquo;m writing integration tests of <em>service2</em> I&rsquo;ll for sure have some points of interaction with <em>service3</em> and <em>service4</em>. Most likely in the majority of cases I&rsquo;ll just mock those interactions in my code but it would be valuable to have a real HTTP call done to the other application. Of course I don&rsquo;t want to download both services and run them only for integration tests - that would be an overkill. That&rsquo;s why the most preferable solution at this point would be to run the stubs of my collaborators.</p>

<p>Since I&rsquo;m too lazy to do things manually I&rsquo;d prefer the stubs to be automatically downloaded for me, the WireMock servers started and fed with the stub definitions.</p>

<p>And that&rsquo;s exactly what <em>Stub Runner</em> can do for you!</p>

<h2>How does it work?</h2>

<h3>Concept</h3>

<p><a href="https://github.com/Codearte/accurest/wiki/8.-Stub-Runner">Stub Runner</a> at its core is using Groovy&rsquo;s Grape mechanism to download the stubs from a given Maven repository. Next it unpacks them to a temporary folder. Let&rsquo;s assume that you have the following structure of your WireMock stubs inside the stub JAR (example for a <code>service3-stubs.jar</code>)</p>

<pre><code>├── META-INF
│   └── MANIFEST.MF
└── mappings
    └── service3
        ├── shouldMarkClientAsFraud.json
        ├── notAWireMockMapping.json
        └── shouldSayHello.json
</code></pre>

<p><em>Stub Runner</em> will scan the whole unpacked JAR for any <code>.json</code> files. There is a convention that stub definitions are placed under the <code>mappings</code> folder. So it will pick <code>shouldMarkClientAsFraud.json</code>, <code>notAWireMockMapping.json</code> and <code>shouldSayHello.json</code> files.</p>

<p>Next, a WireMock instance is started for each dependency and every found JSON is attempted to be parsed as a WireMock stub definition. Any exceptions at this point are ignored (so assuming that <code>notAWireMockMapping.json</code> is not a valid WireMock definition, the exception will be suppressed). In our scenario 2 WireMock servers will be started - one for <code>service3</code> and one for <code>service4</code>.</p>

<p>That way you don&rsquo;t have to copy the stubs manually. The stubs are centralized since they are stored in a Maven repository. It&rsquo;s extremely important cause <em>Stub Runner</em> downloads always the newest version of the stubs so you can be sure that your tests will break the moment someone does an incompatible change.</p>

<h3>API</h3>

<p>From the developer&rsquo;s perspective there are only a handful of <em>Stub Runner&rsquo;s</em> classes that should be used. In the majority of cases you will use the following ones:</p>

<h4>StubFinder</h4>

<p>An interface that allows you to find the URL of the started WireMock instance. You can find that URL by
passing the Ivy notation (<code>groupId:artifactId</code>) or just the <code>artifactId</code> - <em>Stub Runner</em> will try to take care of the rest.</p>

<pre><code class="groovy">interface StubFinder {
  /**
   * For the given groupId and artifactId tries to find the matching
   * URL of the running stub.
   *
   * @param groupId - might be null. In that case a search only via artifactId takes place
   * @return URL of a running stub or null if not found
   */
  URL findStubUrl(String groupId, String artifactId)

  /**
   * For the given Ivy notation {@code groupId:artifactId} tries to find the matching
   * URL of the running stub. You can also pass only {@code artifactId}.
   *
   * @param ivyNotation - Ivy representation of the Maven artifact
   * @return URL of a running stub or null if not found
   */
  URL findStubUrl(String ivyNotation)

  /**
   * Returns all running stubs
   */
  RunningStubs findAllRunningStubs()
}
</code></pre>

<h4>RunningStubs</h4>

<p>A structure representing the already running stubs. Give you some helper methods to retrieve Ivy representation of a particular stub, find a port for a stub etc.</p>

<p><img src="/images/accurest/stubrunner/running_stubs.png" alt="RunningStubs" /></p>

<h4>StubRunning</h4>

<p>A contract for classes that can run the stubs:</p>

<pre><code class="groovy">interface StubRunning extends Closeable, StubFinder {
  /**
   * Runs the stubs and returns the {@link RunningStubs}
   */
  RunningStubs runStubs()

}
</code></pre>

<h4>StubRunner</h4>

<p>Represents a single instance of ready-to-run stubs. It can run the stubs and will return the running instance of WireMock wrapped in <code>RunningStubs</code> class. Since it&rsquo;s implementing <code>StubFinder</code> can also be queried if the current groupid and artifactid are matching the corresponding running stub.</p>

<h4>BatchStubRunner</h4>

<p>If you have multiple services for which you want to run the WireMocks with stubs it&rsquo;s enough to use <code>BatchStubRunner</code>. It iterates over the given <code>Iterable</code> of <code>StubRunner</code> and executes the logic on each of them.</p>

<h2>Running Stub Runner</h2>

<p>In all the examples below let&rsquo;s assume that the stubs are stored in the Maven repository available under <code>http://toomuchcoding.com</code> URL. As <em>service2</em> I&rsquo;d like to download the stubs of <code>com.toomuchcoding:service3</code> and
<code>com.toomuchcoding:service4</code> services.</p>

<h3>Stub Runner as a fat JAR</h3>

<h4>How to use it?</h4>

<p><em>Stub Runner</em> comes with a main class (<code>io.codearte.accurest.stubrunner.StubRunnerMain</code>) which you can run with the following options:</p>

<pre><code> -maxp (--maxPort) N            : Maximum port value to be assigned to the
                                  Wiremock instance. Defaults to 15000
                                  (default: 15000)
 -minp (--minPort) N            : Minimal port value to be assigned to the
                                  Wiremock instance. Defaults to 10000
                                  (default: 10000)
 -s (--stubs) VAL               : Comma separated list of Ivy representation of
                                  jars with stubs. Eg. groupid:artifactid1,group
                                  id2:artifactid2:classifier
 -sr (--stubRepositoryRoot) VAL : Location of a Jar containing server where you
                                  keep your stubs (e.g. http://nexus.net/content
                                  /repositories/repository)
 -ss (--stubsSuffix) VAL        : Suffix for the jar containing stubs (e.g.
                                  'stubs' if the stub jar would have a 'stubs'
                                  classifier for stubs: foobar-stubs ).
                                  Defaults to 'stubs' (default: stubs)
 -wo (--workOffline)            : Switch to work offline. Defaults to 'false'
                                  (default: false)
</code></pre>

<p>You can run that main class from IDE or build yourself a fat JAR. To do that just call the following command:</p>

<pre><code>./gradlew stub-runner-root:stub-runner:shadowJar -PfatJar
</code></pre>

<p>Then inside the <code>build/lib</code> there will be a fat JAR with classifier <code>fatJar</code> waiting for you to execute.</p>

<p>Coming back to our example once the fat JAR is built I would just call the following command the retrieve the stubs of <em>service3</em> and <em>service4</em> from the Maven repository available at <code>http://toomuchcoding.com</code>.</p>

<pre><code>java -jar stub-runner-1.0.4-SNAPSHOT-fatJar.jar -sr http://toomuchcoding.com -s com.toomuchcoding:service3:stubs,com.toomuchcoding.service4
</code></pre>

<h4>When to use it?</h4>

<p>Running <em>Stub Runner</em> as a main class makes most sense when you&rsquo;re running some fast smoke tests on a deployed application where you don&rsquo;t want to download and run all the collaborators of that application. For more rationale behind such an approach you can check my article about <a href="/blog/2015/09/27/microservice-deployment/">Microservice Deployment</a></p>

<h3>Stub Runner JUnit Rule</h3>

<h4>How to use it?</h4>

<p>You can use the <em>Stub Runner&rsquo;s</em> JUnit rule to automatically download and run the stubs during your tests. The <code>AccurestRule</code> implements the <code>StubFinder</code> interface thus you can easily find the URLs of the services that you&rsquo;re interested in.</p>

<p>This is how you could do it with Spock:</p>

<pre><code class="groovy">class SomeSpec extends Specification {

  @ClassRule @Shared AccurestRule rule = new AccurestRule()
      .repoRoot('http://toomuchcoding.com')
      .downloadStub("com.toomuchcoding", "service3")
      .downloadStub("com.toomuchcoding:service4")

  def 'should do something useful when service3 is called'() {
        given:
            URL service3Url = rule.findStubUrl('com.toomuchcoding', 'service3')
        expect:
            somethingUseful(service3Url)
    }

  def 'should do something even more useful when service4 is called'() {
        given:
            URL service4Url = rule.findStubUrl('service4')
        expect:
            somethingMoreUseful(service4Url)
    }
}
</code></pre>

<p>or with plain Java JUnit:</p>

<pre><code>public class SomeTest {

  @ClassRule public static AccurestRule rule = new AccurestRule()
      .repoRoot("http://toomuchcoding.com")
      .downloadStub("com.toomuchcoding", "service3")
      .downloadStub("com.toomuchcoding:service4");

  @Test
  public void should_do_something_useful_when_service3_is_called() {
        URL service3Url = rule.findStubUrl("com.toomuchcoding", "service3");

        somethingUseful(service3Url);
  }

  @Test
  public void should_do_something_even_more_useful_when_service4_is_called() {
        URL service4Url = rule.findStubUrl("service4");

        somethingMoreUseful(service4Url);
  }
}
</code></pre>

<h4>When to use it?</h4>

<p>You can use this rule in any place you want to if we don&rsquo;t provide any integration with an existing framework.</p>

<h3>Stub Runner Spring</h3>

<h4>How to use it?</h4>

<p>You can use the <em>Stub Runner&rsquo;s</em> Spring configuration to download the stubs of your collaborators and run the WireMock server upon Spring context booting. We&rsquo;re providing the <code>StubRunnerConfiguration</code> that you can import in your tests. In that configuration we&rsquo;re registering a <code>StubFinder</code> bean that you can autowire in your tests.</p>

<p>Having the following <code>application.yaml</code> file:</p>

<pre><code class="yml">stubrunner.stubs.repository.root: http://toomuchcoding.com
stubrunner.stubs.ids: com.toomuchcoding:service3:stubs,com.toomuchcoding.service4
</code></pre>

<p>This is how you could do it with Spock</p>

<pre><code class="groovy">@ContextConfiguration(classes = Config, loader = SpringApplicationContextLoader)
class StubRunnerConfigurationSpec extends Specification {

  @Autowired StubFinder stubFinder

  def 'should do something useful when service3 is called'() {
      given:
          URL service3Url = stubFinder.findStubUrl('com.toomuchcoding', 'service3')
      expect:
          somethingUseful(service3Url)
  }

  def 'should do something even more useful when service4 is called'() {
      given:
          URL service4Url = stubFinder.findStubUrl('service4')
      expect:
          somethingMoreUseful(service4Url)
  }

  @Configuration
  @Import(StubRunnerConfiguration)
  @EnableAutoConfiguration
  static class Config {}

}
</code></pre>

<h4>When to use it?</h4>

<p>In your tests if you have Spring and don&rsquo;t have Spring Cloud. Also you can add it in compile time (of course you would have to add some Spring profiles so as not to run it on production) to profit from a &ldquo;developer&rdquo; mode of running microservices. That means that if you boot up your application to click around it - all the stubs around you would have already been downloaded and started.</p>

<h3>Stub Runner Spring Cloud</h3>

<h4>How to use it?</h4>

<p>You can use the <em>Stub Runner&rsquo;s</em> Spring Cloud configuration to profit from the stubbed collaborators when using Spring Cloud&rsquo;s abstractions over service discovery and when you&rsquo;re using Netflix Ribbon. <em>Stub Runner Spring Cloud</em> configuration is an <code>AutoConfiguration</code> so it&rsquo;s automatically started for you.</p>

<p>Let&rsquo;s assume that you&rsquo;re referring to <em>service3</em> as <code>service3</code> in your code and to <em>service4</em> as <code>shouldMapThisNameToService4</code>. That means that you&rsquo;re using for example the <code>@LoadBalanced</code> <code>RestTemplate</code> in the following way (don&rsquo;t use field injection as I do in this example!!):</p>

<pre><code class="groovy">@Component
class SomeClass {

  @Autowired @LoadBalanced RestTemplate restTemplate

  void doSth() {
    // code...
    String service3Response = restTemplate.getForObject('http://service3/name', String)
    String service4Response = restTemplate.getForObject('http://shouldMapThisNameToService4/name', String)
    // more code...
  }

}
</code></pre>

<p>If the service Id that you&rsquo;re using to call other services maps exactly to the name of the artifact Id in a Maven repository then you&rsquo;re lucky and don&rsquo;t have to do anything to find your running stubs. If however that&rsquo;s not the case - don&rsquo;t worry, you&rsquo;ll just have to map it yourself.</p>

<p>The <code>stubrunner.stubs.idsToServiceIds</code> property is the root path to a map in which the <em>key</em> is the <em>artifactID</em> of the downloaded stub and the <em>value</em> is the <em>serviceId</em> used in the code.</p>

<p>Having the following <code>application.yaml</code> file:</p>

<pre><code class="yml">stubrunner.stubs.repository.root: http://toomuchcoding.com
stubrunner.stubs.ids: com.toomuchcoding:service3:stubs,com.toomuchcoding.service4

stubrunner.stubs.idsToServiceIds:
  service4: shouldMapThisNameToService4
</code></pre>

<p>This is how you could do it with Spock</p>

<pre><code class="groovy">@ContextConfiguration(classes = Config, loader = SpringApplicationContextLoader)
class StubRunnerConfigurationSpec extends Specification {

  @Autowired SomeClass someClass

  def 'should not explode'() {
      when:
          someClass.doSth()
      expect:
          noExceptionThrown()
  }

  @Configuration
  @EnableAutoConfiguration
  static class Config {}

}
</code></pre>

<h4>When to use it?</h4>

<p>When you&rsquo;re using Spring Cloud. You can profit from <code>Stub Runner Spring Cloud</code> also in &ldquo;developer&rdquo; mode as presented in the <code>Stub Runner Spring</code> section.</p>

<h3>Additional Configuration Options</h3>

<p>You can set the default value of the Maven repository by means of a system property:</p>

<pre><code>-Dstubrunner.stubs.repository.root=http://your.maven.repo.com
</code></pre>

<p>The list of configurable properties contains:</p>

<table>
<thead>
<tr>
<th> Name </th>
<th> Default value </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> stubrunner.port.range.min </td>
<td> 10000 </td>
<td> Minimal value of a port for a WireMock server </td>
</tr>
<tr>
<td> stubrunner.port.range.max </td>
<td> 15000 </td>
<td> Maximum value of a port for a WireMock server </td>
</tr>
<tr>
<td> stubrunner.stubs.repository.root </td>
<td>  </td>
<td> Address to your M2 repo (will point to local M2 repo if none is provided) </td>
</tr>
<tr>
<td> stubrunner.stubs.classifier </td>
<td> stubs </td>
<td> Default classifier for the JARs containing stubs </td>
</tr>
<tr>
<td> stubrunner.work-offline </td>
<td> false </td>
<td> Should try to connect to any repo to download stubs (useful if there&rsquo;s no internet) </td>
</tr>
<tr>
<td> stubrunner.stubs </td>
<td> </td>
<td> Default comma separated list of stubs to download </td>
</tr>
</tbody>
</table>


<h2>Summary</h2>

<p><em>Stub Runner</em>:</p>

<ul>
<li>Has already proven to be a very useful tool when doing CDC.</li>
<li>Was battle tested and more companies are declaring their interest in using it.</li>
<li>Helps you produce an API that should make both sides (server and the client) equally happy (or unhappy but still they&rsquo;re both equal in their emotions ;) ).</li>
<li>Is language / technology agnostic - you can run it as a fat JAR, use it with Spring, Guice or whatever you want.</li>
<li>Helps you speed up the feedback cycle both from the API design and the compatibility perspective.</li>
</ul>


<h2>Links</h2>

<ul>
<li><a href="https://github.com/Codearte/accurest">AccuREST Github Repository</a></li>
<li><a href="https://github.com/Codearte/accurest/wiki/8.-Stub-Runner">Stub Runner WIKI</a></li>
<li><a href="https://gitter.im/Codearte/accurest">AccuREST Gitter</a></li>
<li><a href="https://github.com/Codearte/accurest-maven-plugin">AccuREST Maven Plugin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON Assert lib released]]></title>
    <link href="http://toomuchcoding.com/blog/2016/02/27/json-assert-lib-released/"/>
    <updated>2016-02-27T23:20:00+01:00</updated>
    <id>http://toomuchcoding.com/blog/2016/02/27/json-assert-lib-released</id>
    <content type="html"><![CDATA[<div class='post'>
I'm really happy to present the <a href="https://github.com/marcingrzejszczak/jsonassert">JSON Assert library</a>&nbsp;-&nbsp;over-the-weekend project that came out from the <a href="https://github.com/Codearte/accurest">AccuREST library</a>. This post will describe the rationale behind creating this tool and how to use it.<br /><br /><br /><a name='more'></a>
<!--more-->
<br /><br /><h4>Rationale</h4>In AccuREST (the Consumer Driven Contracts implementation library) we're creating tests of the server side. For more information on what is AccuREST and what Consumer Driven Contracts is check the <a href="https://github.com/Codearte/accurest/wiki">AccurREST wiki</a>. Anyways, we're checking if the response from the server matches the one described in the contract.<br /><br />So having such a Groovy DSL:<br /><br /><pre style="background: #fff; color: black;">io.codearte.accurest.dsl.GroovyDsl<span style="color: #0100b6; font-weight: 700;">.</span>make {<br />    priority <span style="color: #cd0000; font-style: italic;">1</span><br />    request {<br />        method <span style="color: #d80800;">'POST'</span><br />        url <span style="color: #d80800;">'/users/password'</span><br />        headers {<br />            header <span style="color: #d80800;">'Content-Type'</span>: <span style="color: #d80800;">'application/json'</span><br />        }<br />        body(<br />                <span style="color: #c5060b; font-style: italic;">email</span>: $(stub(optional(regex(email()))), test(<span style="color: #d80800;">'abc@abc.com'</span>)),<br />                <span style="color: #c5060b; font-style: italic;">callback_url</span>: $(stub(regex(hostname())), test(<span style="color: #d80800;">'http://partners.com'</span>))<br />        )<br />    }<br />    response {<br />        status <span style="color: #cd0000; font-style: italic;">404</span><br />        headers {<br />            header <span style="color: #d80800;">'Content-Type'</span>: <span style="color: #d80800;">'application/json'</span><br />        }<br />        body(<br />                <span style="color: #c5060b; font-style: italic;">code</span>: value(stub(<span style="color: #d80800;">"123123"</span>), test(optional(<span style="color: #d80800;">"123123"</span>))),<br />                <span style="color: #c5060b; font-style: italic;">message</span>: <span style="color: #d80800;">"User not found by email = [<span style="color: #26b31a;">${value(test(regex(email())), stub('not.existing@user.com'))}</span>]"</span><br />        )<br />    }<br />}<br /></pre><br />Resulted in creation of the following server side response verification<br /><br /><pre style="background: #fff; color: black;"><span style="color: #c5060b; font-style: italic;">given</span>:<br />  def request <span style="color: #0100b6; font-weight: 700;">=</span> given()<br />    .header(<span style="color: #d80800;">'Content-Type'</span>, <span style="color: #d80800;">'application/json'</span>)<br />    .body(<span style="color: #d80800;">'{"email":"abc@abc.com","callback_url":"http://partners.com"}'</span>)<br /><br /> <span style="color: #c5060b; font-style: italic;">when</span>:<br />  def response <span style="color: #0100b6; font-weight: 700;">=</span> given()<span style="color: #0100b6; font-weight: 700;">.</span>spec(request)<br />    .post(<span style="color: #d80800;">"/users/password"</span>)<br /><br /> <span style="color: #c5060b; font-style: italic;">then</span>:<br />  response<span style="color: #0100b6; font-weight: 700;">.</span>statusCode <span style="color: #0100b6; font-weight: 700;">==</span> <span style="color: #cd0000; font-style: italic;">404</span><br />  response<span style="color: #0100b6; font-weight: 700;">.</span>header(<span style="color: #d80800;">'Content-Type'</span>)  <span style="color: #0100b6; font-weight: 700;">==</span> <span style="color: #d80800;">'application/json'</span><br /> <span style="color: #c5060b; font-style: italic;">and</span>:<br />  DocumentContext parsedJson <span style="color: #0100b6; font-weight: 700;">=</span> JsonPath<span style="color: #0100b6; font-weight: 700;">.</span>parse(response<span style="color: #0100b6; font-weight: 700;">.</span>body<span style="color: #0100b6; font-weight: 700;">.</span>asString())<br />  <span style="color: #0100b6; font-weight: 700;">!</span>parsedJson<span style="color: #0100b6; font-weight: 700;">.</span>read(<span style="color: #d80800;">'''$[?(@.code =~ /(123123)?/)]'''</span>, JSONArray)<span style="color: #0100b6; font-weight: 700;">.</span>empty<br />  <span style="color: #0100b6; font-weight: 700;">!</span>parsedJson<span style="color: #0100b6; font-weight: 700;">.</span>read(<span style="color: #d80800;">'''$[?(@.message =~ /User not found by email = <span style="color: #26b31a;">\\</span>[[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+<span style="color: #26b31a;">\\</span>.[a-zA-Z]{2,4}<span style="color: #26b31a;">\\</span>]/)]'''</span>, JSONArray)<span style="color: #0100b6; font-weight: 700;">.</span>empty<br /><br /></pre><br />AccuREST users stated that their biggest problem is this part:<br /><br /><pre style="background: #fff; color: black;"><span style="color: #0100b6; font-weight: 700;">!</span>parsedJson<span style="color: #0100b6; font-weight: 700;">.</span>read(<span style="color: #d80800;">'''$[?(@.code =~ /(123123)?/)]'''</span>, JSONArray)<span style="color: #0100b6; font-weight: 700;">.</span>empty<br />  <span style="color: #0100b6; font-weight: 700;">!</span>parsedJson<span style="color: #0100b6; font-weight: 700;">.</span>read(<span style="color: #d80800;">'''$[?(@.message =~ /User not found by email = <span style="color: #26b31a;">\\</span>[[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+<span style="color: #26b31a;">\\</span>.[a-zA-Z]{2,4}<span style="color: #26b31a;">\\</span>]/)]'''</span>, JSONArray)<span style="color: #0100b6; font-weight: 700;">.</span>empty<br /></pre><br />They said that JSON Paths are too difficult for them to read.<br /><br />That's why I've created the&nbsp;<a href="https://github.com/marcingrzejszczak/jsonassert">JSON Assert library</a>. So that instead of the aforementioned code one gets sth like this:<br /><br /><pre style="background: #fff; color: black;">  assertThatJson(parsedJson)<span style="color: #0100b6; font-weight: 700;">.</span>field(<span style="color: #d80800;">'code'</span>)<span style="color: #0100b6; font-weight: 700;">.</span>matches(<span style="color: #d80800;">'123123?'</span>)<br />  assertThatJson(parsedJson)<span style="color: #0100b6; font-weight: 700;">.</span>field(<span style="color: #d80800;">'message'</span>)<span style="color: #0100b6; font-weight: 700;">.</span>matches(<span style="color: #d80800;">'User not found by email = <span style="color: #26b31a;">\\</span>[[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+<span style="color: #26b31a;">\\</span>.[a-zA-Z]{2,4}<span style="color: #26b31a;">\\</span>]/)]'</span>);<br /></pre><br /><h4>How to add it to your project</h4><br />If your using Gradle just add (<a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.blogspot.toomuchcoding%22%20a%3A%22jsonassert%22">check the latest version number</a>):<br /><br /><pre style="background: #fff; color: black;"> testCompile `com<span style="color: #0100b6; font-weight: 700;">.</span>blogspot<span style="color: #0100b6; font-weight: 700;">.</span><span style="color: #c5060b; font-style: italic;">toomuchcoding</span>:<span style="color: #c5060b; font-style: italic;">jsonassert</span>:<span style="color: #cd0000; font-style: italic;">0.1</span><span style="color: #cd0000; font-style: italic;">.2</span>`<br /></pre><br />and if Maven just add:<br /><br /><pre style="background: #fff; color: black;"><span style="color: #1c02ff;">&lt;<span style="font-weight: 700;">dependency</span>&gt;</span><br />    <span style="color: #1c02ff;">&lt;<span style="font-weight: 700;">groupId</span>&gt;</span>com.blogspot.toomuchcoding<span style="color: #1c02ff;">&lt;/<span style="font-weight: 700;">groupId</span>&gt;</span><br />    <span style="color: #1c02ff;">&lt;<span style="font-weight: 700;">artifactId</span>&gt;</span>jsonassert<span style="color: #1c02ff;">&lt;/<span style="font-weight: 700;">artifactId</span>&gt;</span><br />    <span style="color: #1c02ff;">&lt;<span style="font-weight: 700;">version</span>&gt;</span>0.1.2<span style="color: #1c02ff;">&lt;/<span style="font-weight: 700;">version</span>&gt;</span><br /><span style="color: #1c02ff;">&lt;/<span style="font-weight: 700;">dependency</span>&gt;</span><br /></pre><h4><br />How to use it</h4><br />Since almost everything in JSON Assert is package scoped you have access to two public classes. One of which is the &nbsp;<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><a href="https://github.com/marcingrzejszczak/jsonassert/blob/master/src/main/java/com/blogspot/toomuchcoding/jsonassert/JsonAssertion.java">JsonAssertion</a></span> class. It gives you a couple of public methods that give you the entry point to the fluent interface of the library.<br /><br />You can check the JavaDocs of the <a href="https://github.com/marcingrzejszczak/jsonassert/blob/master/src/main/java/com/blogspot/toomuchcoding/jsonassert/JsonVerifiable.java">JsonVerifiable</a> interface in order to see what kind of methods can be used.<br /><br /><h4>Examples</h4><div><br />Best examples are <a href="https://github.com/marcingrzejszczak/jsonassert/blob/master/src/test/groovy/com/blogspot/toomuchcoding/jsonassert/JsonAssertionSpec.groovy">tests</a>. I'll show you a couple of them here.<br /><br /><br /><b>Example 1</b><br /><br />Having a JSON:<br /><br /><pre style="background: #fff; color: black;">[ {<br />                                <span style="color: #d80800;">"some"</span> : {<br />                                    <span style="color: #d80800;">"nested"</span> : {<br />                                        <span style="color: #d80800;">"json"</span> : <span style="color: #d80800;">"with value"</span>,<br />                                        <span style="color: #d80800;">"anothervalue"</span>: <span style="color: #cd0000; font-style: italic;">4</span>,<br />                                        <span style="color: #d80800;">"withlist"</span> : [<br />                                            { <span style="color: #d80800;">"name"</span> :<span style="color: #d80800;">"name1"</span>} , {<span style="color: #d80800;">"name"</span>: <span style="color: #d80800;">"name2"</span>}, {<span style="color: #d80800;">"anothernested"</span>: { <span style="color: #d80800;">"name"</span>: <span style="color: #d80800;">"name3"</span>} }<br />                                        ]<br />                                    }<br />                                }<br />                            },<br />                            {<br />                                <span style="color: #d80800;">"someother"</span> : {<br />                                    <span style="color: #d80800;">"nested"</span> : {<br />                                        <span style="color: #d80800;">"json"</span> : <span style="color: #d80800;">"with value"</span>,<br />                                        <span style="color: #d80800;">"anothervalue"</span>: <span style="color: #cd0000; font-style: italic;">4</span>,<br />                                        <span style="color: #d80800;">"withlist"</span> : [<br />                                            { <span style="color: #d80800;">"name"</span> :<span style="color: #d80800;">"name1"</span>} , {<span style="color: #d80800;">"name"</span>: <span style="color: #d80800;">"name2"</span>}<br />                                        ]<br />                                    }<br />                                }<br />                            }<br />                        ]<br /></pre><br /></div><div><br /></div><div>Instead of writing:</div><div><br /><pre style="background: #fff; color: black;">$[<span style="color: #0100b6; font-weight: 700;">*</span>].some.nested.withlist[<span style="color: #0100b6; font-weight: 700;">*</span>].anothernested[<span style="color: #0100b6; font-weight: 700;">?</span>(@.name == <span style="color: #d80800;">'name3'</span>)]<br /></pre></div><div><br /></div><div>you can write<br /><br /><pre style="background: #fff; color: black;"><span style="color: #3c4c72; font-weight: 700;">assertThat</span>(json)<span style="color: #0100b6; font-weight: 700;">.</span>array()<span style="color: #0100b6; font-weight: 700;">.</span>field(<span style="color: #d80800;">"some"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>field(<span style="color: #d80800;">"nested"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>array(<span style="color: #d80800;">"withlist"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>field(<span style="color: #d80800;">"anothernested"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>field(<span style="color: #d80800;">"name"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>isEqualTo(<span style="color: #d80800;">"name3"</span>)<br /></pre><br /><b>Example 2</b><br /><br />Having a JSON:<br /><br /><pre style="background: #fff; color: black;">{<br />    <span style="color: #d80800;">"property1"</span>: [<br />        { <span style="color: #d80800;">"property2"</span>: <span style="color: #d80800;">"test1"</span>},<br />        { <span style="color: #d80800;">"property3"</span>: <span style="color: #d80800;">"test2"</span>}<br />    ]<br />}<br /></pre><br /></div><div><br /></div><div>Instead of writing:</div><div><br /><pre style="background: #fff; color: black;">$.property1[<span style="color: #0100b6; font-weight: 700;">*</span>][<span style="color: #0100b6; font-weight: 700;">?</span>(@.property2 == <span style="color: #d80800;">'test1'</span>)]<br /></pre></div><div><br /></div><div>you can write<br /><br /><pre style="background: #fff; color: black;"><span style="color: #3c4c72; font-weight: 700;">assertThat</span>(json)<span style="color: #0100b6; font-weight: 700;">.</span>array(<span style="color: #d80800;">"property1"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>contains(<span style="color: #d80800;">"property2"</span>)<span style="color: #0100b6; font-weight: 700;">.</span>isEqualTo(<span style="color: #d80800;">"test1"</span>)<br /></pre><br /></div><h4>Future plans</h4><br />It would be nice to:<br /><br /><ul><li>integrate with <a href="http://joel-costigliola.github.io/assertj/">AssertJ</a></li><li>add more <a href="https://github.com/jayway/JsonPath#functions">JSON Path features</a> (functions, filters etc.)</li></ul><div><br /></div><h4>Links</h4><ul><li><a href="https://github.com/marcingrzejszczak/jsonassert">JSON Assert</a></li><li><a href="https://github.com/Codearte/accurest/wiki">AccuREST</a></li><li><a href="https://www.youtube.com/watch?v=daafmTYFoDU">Video about AccuREST </a>by <a href="https://twitter.com/olga_maciaszek">Olga Maciaszek-Sharma</a></li><li><a href="https://github.com/jayway/JsonPath">Jayway JSON Path</a></li><li><a href="http://joel-costigliola.github.io/assertj/">AssertJ</a></li></ul><br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microservice Deployment]]></title>
    <link href="http://toomuchcoding.com/blog/2015/09/27/microservice-deployment/"/>
    <updated>2015-09-27T00:13:00+02:00</updated>
    <id>http://toomuchcoding.com/blog/2015/09/27/microservice-deployment</id>
    <content type="html"><![CDATA[<div class='post'>
It's been a while since my last post. In the meantime of course nothing has changed in terms of the microservice hype. I've been &nbsp;attending many microservice's talks and what I'm always missing are concrete details on many different subjects. One of which is deployment. In this post I'll try to depict how in a big, multinational company one would want to do microservice deployment. I'll walk you through the most basic deployment pipeline that could be created in such an enterprise.<br /><br /><a name='more'></a>
<!--more-->
<br /><h4>The goal</h4>Our goal was to:<br /><br /><b>Enforce standards</b><br /><b><br /></b>Have a unique way of deploying alll microservices - we need to enforce standards<br /><br /><b>Tackle the microservice dependencies complexity issue</b><br /><br />Make the deployment process maintainable from the infrastructure and operations perspective<br /><br /><b>Make the pipeline fast and certain</b><br /><br />Have the greatest possible certainty that our features are working fine.<br />We wanted to make the deployment pipeline as fast as possible.<br />It was crucial to add the possibility to automatically rollback if something goes wrong.<br /><br /><h4>Enforce standards</h4>It is crucial that if you're starting with microservices you start introducing standards. Standards of running applications, configuring them (externalized properties) but also you should enforce standards in how you deploy your applications. At some point in time we have seen that different applications do common tasks in different ways.<br /><br />Why should we bother - we have business value to deliver and not waste time on enforcing standards - your manager might say. Actually he is really wrong because you're wasting plenty of time (thus money) on supporting such nonstandard applications. Imagine how much it needs for the new developers to understand how exactly the rules are set in this particular process.<br /><br />The same relates to deployment and deployment pipelines. That's why we decided to enforce one, single way of deploying microservices.<br /><br /><h4><span style="font-weight: normal;">Tackle the microservice dependencies complexity issue</span></h4><br />If you have two monolithic applications talking to each other and not too many developers working on the codebases you can queue deployment of both apps and always perform end to end tests.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-G80VsWKpIy0/VgbyR9nENVI/AAAAAAABII4/rYV8ZIMJi6A/s1600/monolith.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="124" src="https://2.bp.blogspot.com/-G80VsWKpIy0/VgbyR9nENVI/AAAAAAABII4/rYV8ZIMJi6A/s320/monolith.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Two monolithic applications deployed for end to end testing</td></tr></tbody></table><div class="separator" style="clear: both; text-align: left;">In case of microservices the scale starts to be a problem:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-kggPwWHR-iQ/VgbyhX1x5aI/AAAAAAABIJA/tf2lLkCruxA/s1600/many_microservices.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="207" src="https://2.bp.blogspot.com/-kggPwWHR-iQ/VgbyhX1x5aI/AAAAAAABIJA/tf2lLkCruxA/s320/many_microservices.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Many microservices deployed in different versions</td></tr></tbody></table><div class="separator" style="clear: both; text-align: left;">The questions arise:</div><div class="separator" style="clear: both; text-align: left;"></div><ul><li>Should I queue deployments of microservices on one testing environment or should I have an environment per microservice?&nbsp;</li><ul><li>If I queue deployments people will have to wait for hours to have their tests ran - that can be a problem</li></ul><li>To remove that issue I can have an environment per microservice&nbsp;</li><ul><li>Who will pay the bills (imagine 100 microservices - each having each own environment).&nbsp;</li><li>Who will support each of those environments?</li><li>Should we spawn a new environment each time we execute a new pipeline and then wrap it up or should we have them up and running for the whole day?</li></ul><li>In which versions should I deploy the dependent microservices - development or production versions?</li><ul><li>If I have development versions then I can test my application against a feature that is not yet on production. That can lead to exceptions on production</li><li>If I test against production versions then I'll never be able to test against a feature under development anytime before deployment to production.</li></ul></ul><h4>Make the pipeline fast and certain</h4><div><br /></div><div>Since we really believe in the agile methodology and continuous deployment we would like our features to be delivered to production as fast as possible. When working with the monolithic applications we've faced the following issues:</div><div><ul><li>For monolithic applications we had plenty of unit, integration and end to end tests</li><li>The different types of tests covered the same functionality up to three times</li><li>The tests took a lot of time to run</li></ul><div>Having all of this in mind we wanted not to have such issues with our new deployment pipeline.</div><div><br /></div></div><br /><div class="separator" style="clear: both; text-align: left;"></div><h4>Simplify the infrastructure complexity</h4><div><br /></div><div>Due to technical issues, difficulties to maintain the spawned environments we've decided to simplify the pipeline as much as possible. That's why since we are enthusiasts of TDD and we know what Consumer Driven Contract is we've decided not to do End to End tests. We're deploying our application to a virtual machine where the executed tests don't interfere with other pipelines executed in the very same time.</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-3BIKN1VzDKA/Vgb7oxk8jXI/AAAAAAABIJQ/q_A0LifBgEI/s1600/stubbed_dependencies.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="203" src="https://3.bp.blogspot.com/-3BIKN1VzDKA/Vgb7oxk8jXI/AAAAAAABIJQ/q_A0LifBgEI/s320/stubbed_dependencies.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Execute tests on a deployed microservice on stubbed dependencies</td></tr></tbody></table><div>That way you can look at your application tests (we called them smoke tests) in the following way:</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-7jseO68-q6A/Vgb8h7Ia1CI/AAAAAAABIJc/C8W0S4qZAic/s1600/no_e2e_tests.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="303" src="https://3.bp.blogspot.com/-7jseO68-q6A/Vgb8h7Ia1CI/AAAAAAABIJc/C8W0S4qZAic/s320/no_e2e_tests.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">We're testing microservices in isolation</td></tr></tbody></table><div>Why smoke tests? Because we deliberately want to enforce the testing pyramid in the following way:</div><div><ul><li>A lot of unit tests executed during build time</li><li>Some integration tests running on stubs of dependent services executed during build time</li><li>Not many acceptance tests&nbsp;running on stubs of dependent services executed during build time (these can be treated as special case of integration tests)</li><li>A handful of smoke tests executed on a deployed application to see if the app is really packaged properly</li></ul></div><div><br /></div><div>Such an approach to testing and deployment gives the following benefits:</div><div><ul><li>No need to deploy dependent services</li><li>The stubs used for the tests ran on a deployed microservice are the same as those used during integration tests</li><li>Those stubs have been tested against the application that produces them (check <a href="https://github.com/Codearte/accurest">Accurest</a> for more information)</li><li>We don't have many slow tests running on a deployed application - thus the pipeline gets executed much faster</li><li>We don't have to queue deployments - we're testing in isolation thus pipelines don't interfere with each other</li><li>We don't have to spawn virtual machines each time for deployment purposes</li></ul></div><div><br /></div><div>It brings however the following challenges:</div><div><ul><li>No end to end tests before production - you don't have the full certainty that a feature is working</li><li>Due to this certainty that the functionality is working decreases</li><li>First time the applications will talk in a real way will be on production</li></ul></div><h4>Overcoming fear of uncertainty</h4><div><br /></div><div>The argument that we don't know if a functionality is working properly made us invest more time and effort in tools that will give us more information on how our applications work on production. That's why we've added plenty of monitoring both technical and business via Graphite. Also we've introduced Seyren as the alerting mechanism to ping us immediately when something is really wrong on production.</div><div><br /></div><div>Whatever time you spend on improving your tests, testing environments or UATs with endless hours of clicking - it will never signify that on production your application will run in the same manner.</div><div><br /></div><div>Our decisions were related to trade offs. We decided to give away the complexity in the artificial test environments. That complexity was pushed to the monitoring of production instances. With microservices there is never an easy decision - there's always some price needed to pay.</div><div><br /></div><h4>The technical overview of the solution</h4><div><br /></div><div>We've divided the simplest scenario of the microservice deployment pipeline into the following steps.</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-JmkGUgmrI8Q/Vgb-y9Eg9RI/AAAAAAABIJo/QMa0rkaSfUk/s1600/Microservice%2BPipeline.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="305" src="https://4.bp.blogspot.com/-JmkGUgmrI8Q/Vgb-y9Eg9RI/AAAAAAABIJo/QMa0rkaSfUk/s640/Microservice%2BPipeline.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Microservice deployment pipeline (without A/B testing)</td></tr></tbody></table><div><b><u>Build the app (after commit)</u></b></div><div><br /></div><div>Most preferably we would like after each merge of a PR trigger the deployment pipeline (thus do Continuous Deployment).&nbsp;</div><div><br /></div><div>The result of this step would be to have the application tested in the following ways:</div><div><ul><li>unit and integration tests are ran</li><li>validity of declared stubs specifications is tested against the application itself</li></ul></div><div>Finally what is published to Nexus is the fat-jar of the application together with its stubs.&nbsp;</div><div><br /></div><div><b><u>Deploy to staging</u></b></div><div><br /></div><div>We deploy our freshly built application to the staging environment. <a href="https://github.com/4finance/micro-infra-spring/wiki/Stub-runner">Micro Infra Spring Stub-runner</a> is responsible for downloading the current <b>development</b>&nbsp;versions of stubs of declared dependencies of the microservice.&nbsp;</div><div><br /></div><div>In the first version of the pipeline we've decided to go towards development versions since we would like each of the applications to go live after each commit. That means that there is a high probability that the development version of a stub is in fact the production one. Of course that not necessarily needs to be true - but this is our trade off.</div><div><br /></div><div>In the future versions of the pipeline we would like to test the app against both development and production versions of stubs.&nbsp;</div><div><br /></div><div><b>What is very important to see is that in this step we are upgrading the microservice's DB schema.</b></div><div><b><br /></b></div><div><b><u>Test application rollback scenario</u></b></div><div><br /></div><div>We don't want to rollback the database. If you have MongoDB like databases there is no schema in fact. If you have Liquibase - you can provide the rollback scripts for relational DBs. They however introduce complexity on the DB level.</div><div><br /></div><div>We've decided to go with a trade off that the complexity goes out from the DB level to the code. We're not rolling back the DB but we're rolling back the application. That means that the developers need to write their code to support backwards compatibility.&nbsp;</div><div><br /></div><div><b>That means that the NEW version of the application MUST support the OLD schema of the database. Also developers MUST NOT do backwards incompatible changes in subsequent liquibase scripts.</b></div><div><b><br /></b></div><div>We're running old smoke tests on the rolled back version of the application that is connected to the new version of the schema. That way we can ensure that most probably we will be able to rollback on production without greater issues.</div><div><br /></div><div><b><u>Deploy to production</u></b></div><div><br /></div><div>If the smoke tests have passed and we've checked the rollback procedures we can go live. Here the monitoring part comes in. We need to ensure that we've put all the KPI checking alerts in place. As a part of deployment procedure a review of monitoring and alerts needs to take place.</div><div><br /></div><div>As you can see in the picture the first scenario of live deployment doesn't include 0 downtime approach. That was yet another trade off that we've decided to take. We don't want to tackle the issue of automatic data migration right now. Also for the developers writing code that supports both old and new schema is actually mind blowing. That's why we want to do things a step at a time - for now we kill all the application instances on production, boot one up and &nbsp;change the schema and then boot the rest up too.</div><div><br /></div><br /><div class="separator" style="clear: both; text-align: left;"><b><u>Rollback procedure</u></b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">If our KPI monitoring starts to go all red on production then we need to rollback as fast as possible. Since we've tested the rollback procedure it shouldn't be an issue on production to kill all the instances, download the previous version of the app and run it against the new schema.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><h4 style="clear: both; text-align: left;">Summary</h4><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">As everything related to distributed systems - you can see that microservice deployment is not easy. Actually it's full of trade offs and complexity. Starting from the infrastructure going through testing and finishing with database schema changes.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">The presented solution seems to be an acceptable compromise between time, effort, certainty and feedback.</div></div>

]]></content>
  </entry>
  
</feed>
